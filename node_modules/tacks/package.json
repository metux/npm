{
  "_args": [
    [
      {
        "raw": "tacks@https://registry.npmjs.org/tacks/-/tacks-1.2.6.tgz",
        "scope": null,
        "escapedName": "tacks",
        "name": "tacks",
        "rawSpec": "https://registry.npmjs.org/tacks/-/tacks-1.2.6.tgz",
        "spec": "https://registry.npmjs.org/tacks/-/tacks-1.2.6.tgz",
        "type": "remote"
      },
      "."
    ]
  ],
  "_from": "tacks@>=1.2.2 <1.3.0",
  "_id": "tacks@1.2.6",
  "_inCache": true,
  "_location": "/tacks",
  "_phantomChildren": {
    "strip-ansi": "3.0.1"
  },
  "_requested": {
    "raw": "tacks@https://registry.npmjs.org/tacks/-/tacks-1.2.6.tgz",
    "scope": null,
    "escapedName": "tacks",
    "name": "tacks",
    "rawSpec": "https://registry.npmjs.org/tacks/-/tacks-1.2.6.tgz",
    "spec": "https://registry.npmjs.org/tacks/-/tacks-1.2.6.tgz",
    "type": "remote"
  },
  "_requiredBy": [
    "#DEV:/"
  ],
  "_resolved": "https://registry.npmjs.org/tacks/-/tacks-1.2.6.tgz",
  "_shasum": "04bf61b636d3d0a91cc853fe5b5c3aba552dd45d",
  "_shrinkwrap": null,
  "_spec": "tacks@https://registry.npmjs.org/tacks/-/tacks-1.2.6.tgz",
  "_where": ".",
  "author": {
    "name": "Rebecca Turner",
    "email": "me@re-becca.org",
    "url": "http://re-becca.org/"
  },
  "bin": {
    "tacks": "cmdline.js"
  },
  "bugs": {
    "url": "https://github.com/iarna/tacks/issues"
  },
  "dependencies": {
    "graceful-fs": "^4.1.2",
    "mkdirp": "^0.5.1",
    "rimraf": "^2.5.1",
    "yargs": "^3.32.0"
  },
  "description": "Generate fixture modules from folders",
  "devDependencies": {
    "tap": "^5.7.1"
  },
  "homepage": "https://github.com/iarna/tacks",
  "keywords": [],
  "license": "ISC",
  "main": "index.js",
  "name": "tacks",
  "optionalDependencies": {},
  "readme": "## tacks\n\nGenerate fixture modules from folders\n\n### USAGE\n\nGenerate a fixture from a folder on disk:\n\n```\ntacks /path/to/fixture/example > example.js\n```\n\nCreate and destroy the fixture from your tests:\n\n```\nvar Tacks = require('tacks')\nvar Dir = Tacks.Dir\nvar File = Tacks.File\nvar Symlink = Tacks.Symlink\n\n// I like my fixture paths to match my test filename:\nvar fixturepath = path.join(__dirname, path.basename(__filename, '.js'))\n\nvar example = require('./example.js')\nexample.create(fixturepath)\n…\nexample.remove(fixturepath)\n```\n\nOr create your own fixture inline:\n```\nvar example = new Tacks(Dir({\n  'package.json': File({\n    name: 'example',\n    version: '1.0.0'\n  })\n}))\nexample.create(fixturepath)\n…\nexample.remove(fixturepath)\n```\n\n### STATUS\n\nThis is very much a \"release early\" type release.  Still very much in\nprogress, but being used.\n\n### CLASSES\n\nThese are used in the generated code. It's totally legit to write them directly though.\n\n#### Consturctor\n\n```\nvar fixture = new Tacks(Dir({\n  'package.json': File({\n    name: 'example',\n    version: '1.0.0'\n  })\n}))\n```\n\nCreate a new fixture object based on a `Dir` object, see below.\n\n#### Create Fixture On Disk\n\n```\nfixture.create('/path/to/fixture')\n```\n\nTake the directory and files described by the fixture and create it in `/path/to/fixture`\n\n#### Remove Fixture From Disk\n\n```\nfixture.remove('/path/to/fixture')\n```\n\nCleanup a fixture we installed in `/path/to/fixture`.\n\n#### Add Directory\n\n```\nvar Dir = Tacks.Dir\nvar mydir = Tacks.Dir(dirspec)\n```\n\nCreates a new `Dir` object for consumption by `new Tacks`.  `dirspec` is a\nobject whose properties are the names of files in a directory and whose\nvalues are either `File` objects, `Dir` objects or `Symlink` objects.\n\n#### Add File\n\n```\nvar File = Tacks.File\nvar myfile = Tacks.File(filespec)\n```\n\nCreates a new `File` object for use in `Dir` objects. `filespec` can be\neither a `String`, a `Buffer` or an `Object`. In the last case, it\nwill be stringified with `JSON.stringify` before writing it to disk\n\n#### Add Symlink\n\n```\nvar Symlink = Tacks.Symlink\nvar mysymlink = Tacks.Symlink(destination)\n```\n\nCreates a new `Symlink` object for use in `Dir` objects. `destination` should\neither be relative to where the symlink is being created, or absolute relative\nto the root of the fixture. That is, `Tacks.Symlink('/')` will create a symlink\npointing at the fixture root.\n\n#### Generate Fixture Object From Directory\n\n```\nvar loadFromDir = require('tacks/load-from-dir')\nvar onDisk = loadFromDir('tests/example')\n```\nThe value returned is a `Tacks` object that you can call `create` or\n`remove` on. It's also handy for using in tests use compare an in\nmemory tacks fixture to whatever ended up on disk.\n\n#### Assert Two Fixtures The Same With node-tap\n\n```\nvar test = require('tap').test\nvar tacksAreTheSame = require('tacks/tap').areTheSame\ntest('example', function (t) {\n  return tacksAreTheSame(t, actual, expected, 'got the expected results')\n})\n```\nThe `tacks/tap` submodule is the start of tap assertions for comparing fixtures.\n\n`areTheSame` creates a subtest, and inside that subtest runs a bunch of\nassertions comparing the contents of the two models.  It's smart enough to\nconsider `tacks` equivalent things equal, eg strings & buffers with the same\ncontent.\n\nBecause it creates a subtest, it's async, it returns the subtest (which is\nalso a promise) so you can either return it yourself and your test will\ncomplete when it does, or do something like:\n\n```\n  tacksAreTheSame(t, actual, expected, 'got the expected results').then(t.done)\n```\n\nor\n\n```\n  tacksAreTheSame(t, actual, expected, 'got the expected results').then(function () {\n    … more tests …\n    t.done()\n  })\n```\n\n#### Geneate JavaScript From Directory\n\n```\nvar generateFromDir = require('tacks/generate-from-dir')\nvar fixturestr = Tacks.generateFromDir(dir)\n```\n\nThis is what's used by the commandline– it generates javascript as a string\nfrom a directory on disk.  It works hard to produce something that looks\nlike it might have been typed by a human– It translates JSON on disk into\nobject literals.  And it doesn't quote property names in object literals\nunless it has to.  It uses single quotes when it can.  It double quotes when\nit has to, and escapes when it has no other choice. It includs plain text\nas strings concatenated one per line. For everything else it makes Buffer\nobjects using hex encoded strings as input.\n\n### WANT TO HAVES\n\nThese are things I'll do sooner or late myself.\n\n* Include adding a `.mockFs('/tmp/fixture/path/')` function which returns a\n  patched version of `fs` that, for attempts to read from `/tmp/fixture/path`\n  returns data from the in memory fixture instead of looking at the\n  filesystem.  For injection into tested modules with something like\n  `require-inject`.\n\n### NICE TO HAVES\n\nI'd love to see these, but I may never get time to do them myself.  If\nsomeone else did them though…\n\n* Having some way to control the formatting of the generated output would be\n  nice for folks who don't use `standard`… eg, semicolons, indentation,\n  default quoting. The right answer might be to generate AST objects for\n  use by an existing formatter. Relatedly, it'd be nice to have some\n  standard extension method for the generated sourcecode. Right now I make\n  use of it just by concattenating source code.\n\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/iarna/tacks.git"
  },
  "scripts": {
    "test": "tap test/*.js"
  },
  "version": "1.2.6"
}
