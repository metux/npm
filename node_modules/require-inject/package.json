{
  "_args": [
    [
      {
        "raw": "require-inject@https://registry.npmjs.org/require-inject/-/require-inject-1.4.0.tgz",
        "scope": null,
        "escapedName": "require-inject",
        "name": "require-inject",
        "rawSpec": "https://registry.npmjs.org/require-inject/-/require-inject-1.4.0.tgz",
        "spec": "https://registry.npmjs.org/require-inject/-/require-inject-1.4.0.tgz",
        "type": "remote"
      },
      "."
    ]
  ],
  "_from": "require-inject@>=1.4.0 <1.5.0",
  "_id": "require-inject@1.4.0",
  "_inCache": true,
  "_location": "/require-inject",
  "_phantomChildren": {},
  "_requested": {
    "raw": "require-inject@https://registry.npmjs.org/require-inject/-/require-inject-1.4.0.tgz",
    "scope": null,
    "escapedName": "require-inject",
    "name": "require-inject",
    "rawSpec": "https://registry.npmjs.org/require-inject/-/require-inject-1.4.0.tgz",
    "spec": "https://registry.npmjs.org/require-inject/-/require-inject-1.4.0.tgz",
    "type": "remote"
  },
  "_requiredBy": [
    "#DEV:/"
  ],
  "_resolved": "https://registry.npmjs.org/require-inject/-/require-inject-1.4.0.tgz",
  "_shasum": "62f0cc1ba4a6ba05f678fb93ff10b1e75769926b",
  "_shrinkwrap": null,
  "_spec": "require-inject@https://registry.npmjs.org/require-inject/-/require-inject-1.4.0.tgz",
  "_where": ".",
  "author": {
    "name": "Rebecca Turner",
    "email": "me@re-becca.org",
    "url": "http://re-becca.org"
  },
  "bugs": {
    "url": "https://github.com/iarna/require-inject/issues"
  },
  "dependencies": {
    "caller": "^1.0.1"
  },
  "description": "A simple mock injector compatible needing no instrumentation in the libraries being tested",
  "devDependencies": {
    "standard": "^7.1.2",
    "tacks": "1.0.11",
    "tap": "^2.2.0"
  },
  "homepage": "https://github.com/iarna/require-inject#readme",
  "keywords": [
    "mock",
    "mocks",
    "injection",
    "dependency",
    "require"
  ],
  "license": "ISC",
  "main": "index.js",
  "name": "require-inject",
  "optionalDependencies": {},
  "readme": "require-inject\n--------------\n\nA simple mock injector compatible needing no instrumentation in the libraries being tested\n\n### Example\n\n    var requireInject = require('require-inject');\n\n    var mymod = requireInject('mymod', {\n        'fs' => {\n            stat: function (file,cb) {\n                switch (file) {\n                case 'testfile1': return cb(null,{})\n                case 'testfile2': return cb(new Error('ENOENT'))\n                }\n            }\n        }\n    })\n\n    var myglobal = requireInject.installGlobally('myglobal', { … })\n\n### Usage in your tests\n\n* **`var mymod = requireInject( module, mocks )`**\n\n*module* is the name of the module you want to require.  This is what you'd\npass to `require` to load the module from your script. This means that for\nrelative paths, the path should be relative to your test script, not to the\nthing you're injecting dependencies into.\n\n*mocks* is an object with keys that are the names of the modules you want\nto mock and values of the mock version of the objects.\n\n**requireInject** makes it so that when *module* is required, any of its\ncalls to require for modules inclued in *mocks* will return the mocked\nversion.  It takes care to not impact any other uses of *module*, any\ncalls to require for it will get a version without mocks.\n\n* **`var mymod = requireInject.withClearCache(module, mocks)`**\n\nAs with `requireInject` but your require cache will be cleared before requring\nthe module to have mocks injected into it. This can be useful when your test shares\ndependencies with the module to be mocked and you need to mock a transitive\ndependency of one of those dependencies. That is:\n\n```\nTest → A → B\n\nModuleToTest → A → MockedB\n```\n\nIf we we didn't clear the cache then `ModuleToTest` would get the already\ncached version of `A` and the `MockedB` would never be injected. By clearing the cache\nfirst it means that `ModuleToTest` will get it's own copy of `A` which will then pick\nup any mocks we defined.\n\nPreviously to achieve this you would need to have provided a mock for `A`,\nwhich, if that isn't what you were testing, could be frustrating busy work.\n\n* **`var myglobal = requireInject.installGlobally( module, mocks)`**\n\nAs with `requireInject`, except that the module and its mocks are left in\nthe require cache and any future requires will end up using them too.  This\nis helpful particularly in the case of things that defer loading (that is,\ndo async loading).\n\n* **`var myglobal = requireInject.installGlobally.andClearCache(module, mocks)`**\n\nAs with `requireInject.installGlobally` but clear the cache first as with\n`requireInject.withClearCache`.  Because this globally clears the cache it\nmeans that any requires after this point will get fresh copies of their\nrequired modules, even if you required them previously.\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/iarna/require-inject.git"
  },
  "scripts": {
    "test": "standard && tap test/*.js"
  },
  "version": "1.4.0"
}
