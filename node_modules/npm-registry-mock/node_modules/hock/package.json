{
  "_args": [
    [
      {
        "raw": "hock@https://registry.npmjs.org/hock/-/hock-0.2.5.tgz",
        "scope": null,
        "escapedName": "hock",
        "name": "hock",
        "rawSpec": "https://registry.npmjs.org/hock/-/hock-0.2.5.tgz",
        "spec": "https://registry.npmjs.org/hock/-/hock-0.2.5.tgz",
        "type": "remote"
      },
      "."
    ]
  ],
  "_from": "hock@>=0.2.5 <0.3.0",
  "_id": "hock@0.2.5",
  "_inCache": true,
  "_location": "/npm-registry-mock/hock",
  "_phantomChildren": {},
  "_requested": {
    "raw": "hock@https://registry.npmjs.org/hock/-/hock-0.2.5.tgz",
    "scope": null,
    "escapedName": "hock",
    "name": "hock",
    "rawSpec": "https://registry.npmjs.org/hock/-/hock-0.2.5.tgz",
    "spec": "https://registry.npmjs.org/hock/-/hock-0.2.5.tgz",
    "type": "remote"
  },
  "_requiredBy": [
    "/npm-registry-mock"
  ],
  "_resolved": "https://registry.npmjs.org/hock/-/hock-0.2.5.tgz",
  "_shasum": "164fb050544c46a336ed19916f2f06300858d3ff",
  "_shrinkwrap": null,
  "_spec": "hock@https://registry.npmjs.org/hock/-/hock-0.2.5.tgz",
  "_where": ".",
  "author": {
    "name": "Maciej MaÅ‚ecki",
    "email": "me@mmalecki.com"
  },
  "bugs": {
    "url": "https://github.com/mmalecki/hock/issues"
  },
  "contributors": [
    {
      "name": "Ken Perkins",
      "email": "ken.perkins@rackspace.com"
    }
  ],
  "dependencies": {
    "deep-equal": "0.2.1"
  },
  "description": "A mocking server for HTTP requests",
  "devDependencies": {
    "mocha": "1.9.x",
    "request": "2.20.x",
    "should": "1.2.x"
  },
  "engines": {
    "node": ">=0.8.x"
  },
  "homepage": "https://github.com/mmalecki/hock#readme",
  "keywords": [
    "mock",
    "http",
    "test"
  ],
  "main": "./lib/hock",
  "name": "hock",
  "optionalDependencies": {},
  "readme": "# hock [![Build Status](https://secure.travis-ci.org/mmalecki/hock.png?branch=master)](http://travis-ci.org/mmalecki/hock)\n\nAn HTTP mocking server based on [Nock](https://github.com/flatiron/nock).\n\n## Overview\n\nHock is an HTTP mocking server with an API designed to closely match that of Nock. The key difference between Nock and Hock is that nock works by overriding `http.clientRequest`, allowing requests to be intercepted before they go over the wire.\n\nHock is designed as a fully functioning HTTP service. You enqueue requests and responses in a similar fashion to Nock:\n\n```Javascript\n\n    var hock = require('hock'),\n        request = require('request');\n\n    hock.createHock(function(err, hockServer) {\n        var port = hockServer.address().port;\n\n        hockServer\n            .get('/some/url')\n            .reply(200, 'Hello!');\n\n        request('http://localhost:' + port + '/some/url', function(err, res, body) {\n           console.log(body);\n        });\n    });\n\n```\n\nA port can be optionally specified when creating the server:\n\n```Javascript\n    hock.createHock(12345, function(err, hockServer) {\n        ....\n    });\n```\n\nUnlike Nock, you create a `Hock` server with a callback based factory method. Behind the scenes, this spins up the new HTTP service, and begins listening to requests.\n\n## HTTP Methods\n\nHock supports the 5 primary HTTP methods at this time:\n\n* GET\n* POST\n* PUT\n* DELETE\n* HEAD\n\n```Javascript\n    // Returns a hock Request object\n    var req = hockServer.get(url, requestHeaders);\n```\n\n```Javascript\n    // Returns a hock Request object\n    var req = hockServer.delete(url, requestHeaders);\n```\n\n```Javascript\n    // Returns a hock Request object\n    var req = hockServer.post(url, body, requestHeaders);\n```\n\n```Javascript\n    // Returns a hock Request object\n    var req = hockServer.put(url, body, requestHeaders);\n```\n\n```Javascript\n    // Returns a hock Request object\n    var req = hockServer.head(url, requestHeaders);\n```\n\n## Request Object\n\nAll of these methods return an instance of a `Request`, a hock object which contains all of the state for a mocked request. To define the response and enqueue into the `hockServer`, call either `reply` or `replyWithFile` on the `Request` object:\n\n```Javascript\n    // returns the current hockServer instance\n    req.reply(statusCode, body, responseHeaders);\n```\n\n```Javascript\n    // returns the current hockServer instance\n    req.replyWithFile(statusCode, filePath, responseHeaders);\n```\n\n## Multiple matching requests\n\nYou can optionally tell hock to match multiple requests for the same route:\n\n```Javascript\n    hockServer.put('/path/one', {\n        foo: 1,\n        bar: {\n            baz: true\n            biz: 'asdf1234'\n        }\n    })\n    .min(4)\n    .max(10)\n    .reply(202, {\n        status: 'OK'\n    })\n```\n\nCall `many` if you need to handle at least one, possibly\nmany requests:\n\n```Javascript\n    hockServer.put('/path/one', {\n        foo: 1,\n        bar: {\n            baz: true\n            biz: 'asdf1234'\n        }\n    })\n    .many() // min 1, max Unlimited\n    .reply(202, {\n        status: 'OK'\n    })\n```\n\nProvide custom min and max options to `many`:\n\n```Javascript\n    hockServer.put('/path/one', {\n        foo: 1,\n        bar: {\n            baz: true\n            biz: 'asdf1234'\n        }\n    })\n    .many({\n        min: 4,\n        max: 10\n    })\n    .reply(202, {\n        status: 'OK'\n    })\n```\n\nSet infinite number of requests with `max(Infinity)`:\n\n```Javascript\n    hockServer.put('/path/one', {\n        foo: 1,\n        bar: {\n            baz: true\n            biz: 'asdf1234'\n        }\n    })\n    .max(Infinity)\n    .reply(202, {\n        status: 'OK'\n    })\n```\n\nIf you don't care how many or how few requests are served, you can use `any`:\n\n```Javascript\n    hockServer.put('/path/one', {\n        foo: 1,\n        bar: {\n            baz: true\n            biz: 'asdf1234'\n        }\n    })\n    .any() // equivalent to min(0), max(Infinity)\n    .reply(202, {\n        status: 'OK'\n    })\n```\n### hockServer.done() with many\n\n`hockServer.done()` will verify the number of requests fits within the\nminimum and maximum constraints specified by `min`, `max`, `many` or `any`:\n\n```js\nhockServer.get('/').min(2)\nrequest.get('/', function() {\n  hockServer.done(function(err) {\n    console.error(err) // error, only made one request\n  })\n})\n```\n\nIf the number of requests doesn't verify and you don't supply a callback\nto `hockServer.done()` it will throw!\n\n## Chaining requests\n\nAs the `reply` and `replyWithFile` methods return the current hockServer, you can chain them together:\n\n```Javascript\n\n    hockServer.put('/path/one', {\n        foo: 1,\n        bar: {\n            baz: true\n            biz: 'asdf1234'\n        }\n    })\n    .reply(202, {\n        status: 'OK'\n    })\n    .get('/my/file/should/be/here')\n    .replyWithFile(200, __dirname + '/foo.jpg');\n\n```\n\n## Matching requests\n\nWhen a request comes in, hock iterates through the queue in a First-in-first-out approach, so long as the request matches. The criteria for matching is based on the method and the url, and additionally the request body if the request is a `PUT` or `POST`. If you specify request headers, they will also be matched against before sending the response.\n\n## Path filtering\n\nYou can filter paths using regex or a custom function, this is useful for things like timestamps that get appended to urls from clients.\n\n```Javascript\n\n    hockServer\n        .filteringPathRegEx(/timestamp=[^&]*/g, 'timestamp=123')\n        .get('/url?timestamp=123')\n        .reply(200, 'Hi!');\n\n```\n\n```Javascript\n\n    hockServer\n        .filteringPath(function (p) {\n            return '/url?timestamp=XXX';\n        })\n        .get('/url?timestamp=XXX')\n        .reply(200, 'Hi!');\n\n```\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/mmalecki/hock.git"
  },
  "scripts": {
    "test": "make test"
  },
  "version": "0.2.5"
}
